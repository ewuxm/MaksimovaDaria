# Блочная (корзинная) сортировка
### Определение
Алгоритм блочная сортировка (bucket sort) — это алгоритм, который распределяет элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их значений. После этого каждая корзина сортируется отдельно (либо тем же методом рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины объединяются обратно в один массив.
### Объяснение работы алгоритма
• Проверка входных данных: Алгоритм начинает с проверки, что массив не пустой (if len(arr) == 0)

• Определение диапазона: Находится минимальное и максимальное значение в массиве для определения диапазона данных (min_val = min(arr), max_val = max(arr))

• Создание корзин: Создается количество корзин, равное количеству элементов в массиве (buckets = [[] for _ in range(num_buckets)])

• Распределение по корзинам: Каждый элемент помещается в соответствующую корзину с помощью формулы вычисления индекса:
index = int((value - min_val) / (max_val - min_val + 1) * (num_buckets - 1))

• Сортировка корзин: Каждая корзина сортируется отдельно с помощью встроенного алгоритма сортировки (sorted_bucket = sorted(bucket))

• Объединение результатов: Отсортированные корзины объединяются в результирующий массив (sorted_arr.extend(sorted_bucket))

### Временная сложность
Временная сложность: O(n), когда данные равномерно распределены по корзинам

### Почему такая сложность
Распределение по корзинам: O(n) - каждый элемент обрабатывается один раз
#
# Блинная сортировка
### Определение
Алгоритм блинной сортировки (Pancake Sort) — это алгоритм сортировки, который упорядочивает элементы массива с помощью операции "переворота" (flip) первых k элементов массива, имитируя переворачивание стопки блинов.

### Объяснение работы алгоритма:
• Поиск максимума: На каждом шаге находится индекс максимального элемента среди первых n элементов массива (max_idx = find_max_index(arr, current_size))

• Поднятие максимума: Если максимальный элемент находится не на своей позиции, массив переворачивается так, чтобы максимальный элемент оказался в начале (flip(arr, max_idx))

• Установка на место: Массив снова переворачивается, чтобы максимальный элемент занял свою окончательную позицию в конце текущей части массива (flip(arr, current_size - 1))

• Уменьшение размера: Размер обрабатываемой части массива уменьшается на 1, и процесс повторяется для оставшихся элементов (current_size -= 1)

### Временная сложность
Временная сложность — O(n)

### Почему
Внешний цикл: Выполняется n-1 раз (от n до 2 элементов)
# 
# Сортировка бусинами (гравитационная)
### Определение
Алгоритм сортировки бусинками (Bead Sort), также известный как гравитационная сортировка (Gravity Sort) — это алгоритм естественной сортировки, который имитирует падение бусинок под действием гравитации. Алгоритм работает только с целыми неотрицательными числами.

### Объяснение работы алгоритма:
• Создание матрицы бусинок: Создается матрица размером N×M, где N - количество чисел в массиве, M - максимальное число в массиве. Каждая строка заполняется единицами в количестве, соответствующем значению числа (beads_matrix[row, :arr[row]] = 1)

• Применение гравитации: В каждом столбце все "бусинки" (единицы) опускаются вниз под действием "гравитации". Для этого вычисляется количество единиц в столбце и они размещаются в начале столбца (beads_matrix[:,col] = np.concatenate([np.ones(column_sum), np.zeros(rows-column_sum)]))

• Преобразование обратно в числа: Каждая строка преобразуется обратно в число путем подсчета количества оставшихся в ней "бусинок" (count = sum(beads_matrix[row,:]))

### Временная сложность
Временная сложность — O(n × m), где n - количество элементов, m - максимальное значение элемента

### Почему:
Заполнение матрицы: Требуется O(n × m) операций для инициализации матрицы. Обработка столбцов: Каждый из m столбцов обрабатывается за O(n) операций. Подсчет результатов: Каждая из n строк обрабатывается за O(m) операций
#
# Поиск скачками
### Определение
Алгоритм поиска скачками (Jump Search) — это алгоритм поиска в отсортированном массиве, который работает путем прыжков фиксированного размера вперед, пока не найдет интервал, содержащий искомый элемент, после чего выполняет линейный поиск в этом интервале.

### Объяснение работы алгоритма:
• Определение размера скачка: Вычисляется оптимальный размер прыжка как квадратный корень из длины массива (step = int(math.sqrt(length)))

• Поиск нужного блока: Алгоритм совершает прыжки фиксированного размера, пока не найдет блок, где значение элемента в конце блока становится больше или равно целевому значению (while arr[min(step, length)-1] < target)

• Линейный поиск в блоке: После определения нужного блока выполняется линейный поиск от начала блока до его конца (while arr[prev] < target)

• Проверка найденного элемента: Если элемент найден, возвращается его индекс, иначе возвращается -1 (if arr[prev] == target)

### Временная сложность
Временная сложность — O(√n)

### Почему
Фаза прыжков: Выполняется не более n/√n = √n прыжков. В худшем случае выполняется √n сравнений внутри блока
#
# Экспоненциальный поиск
### Определение
Алгоритм экспоненциального поиска (Exponential Search) — это алгоритм поиска в отсортированном массиве, который сочетает в себе экспоненциальное расширение границ поиска с последующим бинарным поиском в найденном диапазоне.

### Объяснение работы алгоритма:
• Проверка граничных условий: Алгоритм начинает с проверки, что массив не пуст и целевой элемент находится в пределах диапазона массива (if not arr or arr[0] > target or arr[-1] < target)

• Экспоненциальное расширение границ: Алгоритм последовательно удваивает верхнюю границу поиска (bound *= 2), пока не найдет диапазон, где значение элемента становится больше или равно целевому значению (while bound < len(arr) and arr[bound] < target)

• Бинарный поиск в диапазоне: После определения подходящего диапазона выполняется стандартный бинарный поиск между левой границей (bound // 2) и правой границей (min(bound, len(arr) - 1))

• Возврат результата: Если элемент найден, возвращается его индекс, иначе возвращается -1

### Временная сложность
Временная сложность — O(log i), где i — позиция искомого элемента

### Почему:
Фаза экспоненциального расширения: Требуется O(log i) шагов для нахождения диапазона. Фаза бинарного поиска: В найденном диапазоне размером O(i) выполняется O(log i) сравнений.
# 
#

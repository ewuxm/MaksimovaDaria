# Анализ алгоритма сортировки выбором
### Определение
Алгоритм сортировки выбором (Selection Sort) — это алгоритм, который на каждом шаге находит минимальный элемент среди последних и меняют его местами с текущим элементом в массиве.
### Объяснение работы алгоритма: 
•	На каждом шаге ищется самый маленький элемент в оставшейся неотсортированной части массива (for (int j = i + 1; j < n; j++)).

•	Этот минимальный элемент меняется местами с первым элементом этой части массива (arr[i] = arr[min_idx]).

•	После этого считается, что эта часть массива отсортирована, и алгоритм переходит к следующему элементу и оставшейся части массива (for (int i = 0; i < n; i++)).

•	Процесс повторяется, пока весь массив не станет отсортирован.
### Временная сложность
Временная сложность — O(n²). 
### Почему: наличие внешнего и внутреннего циклов приводит к временной сложности O(n²).
#
# Анализ алгоритма сортировки обменом (пузырьком)
### Определение
Алгоритм сортировка обменом (пузырьком) (Bubble Sort) — это алгоритм, который проходит по списку несколько раз, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. Процесс повторяется до тех пор, пока список полностью не отсортируется.
### Объяснение работы алгоритма:
•	Алгоритм проходит по массиву, сравнивая каждый элемент со следующим (for (int j = 0; j < n - i - 1; j++)).

•	Если текущий элемент больше следующего, они меняются местами (if (arr[j] > arr[j + 1])).

•	После каждого полного прохода наибольший из неотсортированных элементов "всплывает" в конец массива, занимая свою окончательную позицию.

•	Процесс повторяется для всех элементов, пока массив не будет полностью отсортирован (for (int i = 0; i < n - 1; i++)).
### Временная сложность
Временная сложность — O(n²).
### Почему: Наличие вложенных циклов приводит к тому, что количество операций пропорционально квадрату размера массива. Первый проход выполняет n-1 сравнений, второй n-2, и так далее, что в сумме дает O(n²).
#
# Анализ алгоритма сортировки вставками 
### Определение
Алгоритм сортировки вставками (Insertion Sort) — это алгоритм, который строит отсортированную часть массива, постепенно вставляя каждый новый элемент в правильную позицию среди уже упорядоченных элементов.
### Объяснение работы алгоритма:
•	Алгоритм начинает со второго элемента массива и последовательно обрабатывает все элементы справа от него (for (int i = 1; i < size; i++)).

•	Для каждого текущего элемента (key) происходит поиск правильной позиции в уже отсортированной левой части массива.

•	Элементы, большие чем key, сдвигаются на одну позицию вправо, чтобы освободить место для вставки (while (j >= 0 && arr[j] > key)).

•	Текущий элемент вставляется на найденную правильную позицию в отсортированной части массива (arr[j + 1] = key).
### Временная сложность
Временная сложность — O(n²).
### Почему: Наличие вложенного цикла while внутри внешнего цикла for приводит к квадратичной сложности.
#
# Анализ алгоритма сортировки слиянием
### Определение 
Алгоритм сортировки слиянием (Merge Sort) — это алгоритм, который использует стратегию «разделяй и властвуй», рекурсивно разделяя массив на две половины, сортируя их и затем объединяя отсортированные половины в один упорядоченный массив.
### Объяснение работы алгоритма:
•	Массив рекурсивно разделяется на две примерно равные части до тех пор, пока не останутся подмассивы размером в один элемент (mergeSort(arr, l, m) и mergeSort(arr, m+1, r)).

•	Каждая пара отсортированных подмассивов объединяется в один отсортированный массив с помощью процедуры слияния.

•	При слиянии сравниваются элементы из двух подмассивов и выбирается наименьший для помещения в результирующий массив (while(i < tempLeft.size() && j < tempRight.size())).

•	Оставшиеся элементы из любого подмассива добавляются в конец результирующего массива.
### Временная сложность
Временная сложность — O(n log n).
### Почему: Алгоритм рекурсивно делит массив пополам, создавая log n уровней рекурсии. На каждом уровне выполняется операция слияния с линейной сложностью O(n). Перемножение этих величин дает общую сложность O(n log n).
#
# Анализ алгоритма сортировки Шелла
### Определение 
Алгоритм сортировки Шелла (Shell Sort) — это алгоритм, который является обобщением сортировки вставками и сортирует элементы, находящиеся на определенном расстоянии друг от друга, постепенно уменьшая это расстояние до единицы.
### Объяснение работы алгоритма:
•	Алгоритм начинается с большого шага (расстояния между сравниваемыми элементами), который постепенно уменьшается (h //= 3).

•	На каждом шаге выполняется сортировка вставками для элементов, расположенных на расстоянии h друг от друга (for i in range(h, n)).

•	Элементы сравниваются и перемещаются внутри своих подпоследовательностей, пока не будут упорядочены относительно шага h (while j >= h and arr[j-h] > temp).

•	Процесс повторяется с уменьшающимся шагом до тех пор, пока шаг не станет равным 1, после чего выполняется финальная сортировка вставками.
### Временная сложность
Временная сложность — от O(n log²n) до O(n²) в зависимости от выбранной последовательности шагов.
### Почему: Алгоритм использует вложенные циклы, но внутренний цикл (по j) не всегда проходит n раз, как в пузырьке. Количество итераций зависит от gap. В среднем случае количество итераций внутреннего цикла растет медленнее, чем n, приводя к сложности между O(n) и O(n^2).
#
# Анализ алгоритма быстрой сортировки
### Определение 
Алгоритм быстрой сортировки (Quick Sort) — это алгоритм, который использует стратегию «разделяй и властвуй», выбирая опорный элемент и разделяя массив на две части: элементы меньше опорного и элементы больше опорного, после чего рекурсивно сортирует эти части.
### Объяснение работы алгоритма:
•	Если массив содержит 0 или 1 элемент, он считается уже отсортированным (if len(arr) <= 1).

•	Выбирается опорный элемент — в данной реализации средний элемент массива (pivot = arr[len(arr)//2]).

•	Массив разделяется на три части: элементы меньше опорного, равные опорному и больше опорного (left = [x for x in arr if x < pivot], middle = [x for x in arr if x == pivot], right = [x for x in arr if x > pivot]).

•	Алгоритм рекурсивно применяется к левой и правой частям, после чего результаты объединяются (return quicksort(left) + middle + quicksort(right)).
### Временная сложность
Временная сложность — O(n log n) в среднем случае, O(n²) в худшем случае.
### Почему: В среднем случае массив делится пополам на каждом уровне рекурсии, создавая log n уровней, на каждом из которых выполняется O(n) операций. В худшем случае (когда опорный элемент всегда минимальный или максимальный) глубина рекурсии составляет n уровней, что дает O(n²).
#
# Анализ пирамидальной сортировки
### Определение


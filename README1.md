• сортировка выбором
Сортировка выбором (Selection Sort) — на каждом шаге алгоритма находят минимальный элемент среди последних и меняют его местами с текущим элементом в массиве.
Объяснение работы алгоритма: 
•	На каждом шаге ищется самый маленький элемент в оставшейся неотсортированной части массива.
•	Этот минимальный элемент меняется местами с первым элементом этой части массива.
•	После этого считается, что эта часть массива отсортирована, и алгоритм переходит к следующему элементу и оставшейся части массива.
•	Процесс повторяется, пока весь массив не станет отсортирован.
Время выполнения и сложность в нотации Big-O
Внешний цикл выполняется n - 1 раз. В худшем, среднем и лучшем случаях — O(n²), так как количество сравнений не зависит от исходного порядка элементов. Обмен элементов выполняется (O(n)) раз, но это значительно меньшая часть по сравнению с количеством сравнений, так как обмены всего лишь один или несколько на итерацию.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
• сортировка обменом (пузырек)
Сортировка обменом (пузырьком) (Bubble Sort) — алгоритм проходит по списку несколько раз, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. Процесс повторяется до тех пор, пока список полностью не отсортируется.
Объяснение работы алгоритма: 
•	Повторно проходить по массиву, сравнивая соседние элементы.
•	Если они стоят в неправильном порядке (текущий больше следующего), меняем их местами.
•	После каждого такого прохода на конце "выталкивается" наиболее крупный элемент в конец массива — он занимает свою окончательную позицию.
•	Процесс повторяется, пока весь массив не станет отсортирован.
Время выполнения и сложность в нотации Big-O
Первый проход внутреннего цикла выполняет n-1 сравнений. Второй проход — n-2 сравнений. И так далее, до 1 сравнения в последнем проходе. Это арифметическая прогрессия, сумма которой порядка ( O(n^2) ).
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
• сортировка вставками
Сортировка вставками (Insertion Sort) — алгоритм строит отсортированную часть списка, постепенно вставляя каждый элемент на своё место. Он начинает с первого элемента и перемещается вправо, сравнивая каждый элемент с предыдущими элементами и вставляя его на правильное место.
Объяснение работы алгоритма: 
•	Проходим по массиву слева направо, начиная со второго элемента (индекс 1).
•	Для каждого текущего элемента (key) ищем место в уже отсортированной части массива слева (от начала массива до элемента перед текущим).
•	Вставляем текущий элемент (key) в правильную позицию внутри отсортированной части, сдвигая при необходимости остальные элементы вправо.
Время выполнения и сложность в нотации Big-O
Для каждого элемента в худшем случае внутренний цикл while может пройтись по всей уже отсортированной части массива. В худшем случае, если массив отсортирован в обратном порядке, каждый элемент приходится вставлять в начало массива, проходя все уже отсортированные элементы. Итог: Общая временная сложность в худшем случае : O(n^2), Общая временная сложность в лучшем случае: O(n)
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
• сортировка слиянием
Сортировка слиянием (Merge Sort) — алгоритм состоит в разделении массива пополам, сортировке половин и их слиянии.
Объяснение работы алгоритма: 
Сортировка слиянием основывается на принципе «разделяй и властвуй». Этот принцип заключается в следующем:
•	Разделение массива на две примерно равные части.
•	Отсортировка каждой из этих частей независимо друг от друга.
•	Последующее слияние отсортированных частей в одну большую отсортированную последовательность.
Время выполнения и сложность в нотации Big-O
Алгоритм рекурсивно делит массив на две половины, повторяя операцию деления до достижения элементарных фрагментов. Количество уровней рекурсии пропорционально двоичному логарифму числа элементов (O(logn)). На каждом уровне рекурсии нам приходится обрабатывать весь массив целиком, следовательно, общая работа на всех уровнях составляет O(n). Следовательно, временная сложность алгоритма сортировки слиянием выражается формулой: T(n)=O(n⋅logn)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
• сортировка Шелла
Сортировка Шелла (Shellsort) — является модификацией сортировки вставками, сортирует между собой элементы, стоящие на местах, кратных определённому шагу.
Объяснение работы алгоритма: 
•	Частичные сортировки: Массив делится на подгруппы, расположенные на определённом расстоянии друг от друга, и каждая такая группа сортируется методом вставок.
•	Уменьшение шага: По завершении одной серии сортировок шаг уменьшается, и процесс повторяется снова, но уже с меньшей величиной шага.
•	Завершение: Процесс заканчивается, когда шаг достигает единицы, и производится обычная сортировка вставками над всеми элементами массива.
Время выполнения и сложность в нотации Big-O
Оптимизированные версии могут достигать сложности порядка O(n * log2n) или даже ближе к линейному O(n * logn). В худшем случае (неэффективные интервалы) сложность может ухудшиться до O(n2), однако практически такие случаи встречаются редко. Таким образом, Shell Sort демонстрирует высокую эффективность на практике, особенно для небольших и средних размеров массивов, обеспечивая хорошую производительность за счёт снижения количества необходимых сравнений и обменов по сравнению с простой сортировкой вставками.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
• быстрая сортировка
Быстрая сортировка (Quick Sort) — один из самых известных и широко используемых алгоритмов сортировки. Алгоритм состоит в выборе опорного элемента, разделении массива на две части относительно опорного (одна — все элементы, меньшие опорного элемента, вторая — большие), и в сортировке полученных частей рекурсивным вызовом себя от них.
Объяснение работы алгоритма: 
•	Базовый случай: Если массив пуст или содержит всего один элемент, возвращаем его как уже отсортированный.
•	Выбор опорного элемента (pivot): Из массива выбирается некоторый элемент (обычно центральный), который служит точкой отсечения.
•	Разбиение массива: Все элементы массива распределяются на две части — одна содержит элементы, меньшие опорного, вторая — большие, а сами элементы, равные опорному, остаются в середине.
•	Рекурсия: Алгоритм рекурсивно применятся к обеим получившимся частям, после чего результаты объединяются вместе.
Время выполнения и сложность в нотации Big-O
Средняя временная сложность: O(n * logn). Худший случай (при неудачном выборе опорного элемента): O(n2). Однако на практике этот случай встречается крайне редко, если выбирать хороший опорный элемент (например, рандомизировать выбор).
• пирамидальная сортировка
Пирамидальная сортировка — алгоритм строит кучу из исходного списка, затем постепенно извлекает наибольший элемент из кучи и помещает его в конец списка.
Объяснение работы алгоритма: 
•	Построение Max-Heap: Массив сначала преобразуется в бинарную кучу типа "максимум", где каждый родительский элемент больше своих детей.
•	Перебор и замена элементов: Постепенно вытаскиваем самый большой элемент (корень кучи) и кладём его в конец массива, затем восстанавливаем кучу заново, исключая обработанный элемент.
•	Итерация: Продолжаем предыдущие шаги, пока весь массив не окажется отсортированным.
Время выполнения и сложность в нотации Big-O
Построение кучи занимает O(n) операций. Каждая операция удаления вершины (перестановка и восстановление кучи) требует около O(logn) действий, поскольку высота дерева пропорциональна логарифму числа элементов. Так как таких операций потребуется ровно столько, сколько элементов в массиве (n), общая временная сложность составляет O(n * logn).
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
• последовательный поиск
Последовательный (линейный) поиск — простейший вид поиска заданного элемента на некотором множестве. Осуществляется путём последовательного сравнения очередного рассматриваемого значения с искомым до тех пор, пока эти значения не совпадут. Этот метод является наименее эффективным, так как его временная сложность составляет O(n), где n — количество элементов в списке. Однако он прост в реализации и может быть полезен для небольших списков или в тех случаях, когда данные не отсортированы.
Объяснение работы алгоритма: 
•	Получение аргументов: Функция получает список arr и цель поиска target.
•	Итерационный перебор: Используется циклический перебор всех элементов списка с помощью enumerate(), чтобы одновременно получать индекс и значение каждого элемента.
•	Сравнение: Внутри цикла проверяется каждое значение на равенство цели поиска. Если найдено совпадение, функция немедленно возвращает индекс этого элемента.
•	Результат: Если цикл пройден целиком и совпадение не найдено, возвращается None, что означает отсутствие искомого элемента в списке.

Время выполнения и сложность в нотации Big-O
Лучшая ситуация: Если искомое значение находится в самом начале списка, алгоритм выполнит проверку только одного элемента и завершится мгновенно. Следовательно, лучшая временная сложность — O(1). Средняя ситуация: В среднем, придется пройти половину элементов списка, чтобы найти нужный элемент. Но, поскольку мы говорим о порядке роста, среднее время также составит O(n), где n — длина списка. Худшая ситуация: Если искомый элемент находится в конце списка или вовсе отсутствует, алгоритм должен проверить абсолютно все элементы. Поэтому худшая временная сложность — O(n).
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
• бинарный поиск
Бинарный (двоичный, дихотомический) поиск — это поиск заданного элемента на упорядоченном множестве, осуществляемый путём неоднократного деления этого множества на две части таким образом, что искомый элемент попадает в одну из этих частей. Поиск заканчивается при совпадении искомого элемента с элементом, который является границей между частями множества или при отсутствии искомого элемента. Преимуществом бинарного поиска является более низкая трудоёмкость по сравнению с последовательным поиском. Недостаток заключается в том, что он применим только на отсортированных множествах.
Объяснение работы алгоритма:
•	Начало поиска: Устанавливаются границы поиска (low и high), охватывающие весь массив.
•	Деление пополам: На каждой итерации определяется середина диапазона (mid), и проверяется, совпадает ли элемент с искомым значением.
•	Переход к половине: Если середина меньше искомого, сдвигаемся вправо (обновляя low), если больше — влево (обновляя high).
•	Окончание поиска: Если диапазон сужается до минимума (остаётся менее одного элемента), поиск останавливается, и если элемент не найден, возвращается -1.
Время выполнения и сложность в нотации Big-O
o	Бинарный поиск основан на постоянном делении массива пополам, поэтому временная сложность в обозначениях Big-O составляет O (logN), где N — количество элементов в массиве.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
• интерполирующий поиск
Интерполирующий поиск — это алгоритм поиска для отсортированных наборов данных, таких как массивы или списки. Он предсказывает позицию нужного элемента на основе разницы значений. Эффективен, если элементы распределены достаточно равномерно.
Объяснение работы алгоритма:
•	Интерполяция позиции: Скрипт вычисляет вероятную позицию искомого элемента, основываясь на соотношении между минимальным/максимальным значениями и самим искомым числом.
•	Сужение поиска: В зависимости от полученного значения, дальнейший поиск продолжается либо в верхней, либо нижней части массива.
•	Критерии остановки: Если элемент найден или границы поиска пересеклись, поиск завершается.
•	Оптимизация поиска: Благодаря учёту распределения данных, алгоритм быстрее находит элемент по сравнению с бинарным поиском, если данные действительно равномерно распределены.
Время выполнения и сложность в нотации Big-O
Лучший случай: O(1) (элемент найден сразу). Средний случай: O(loglogN) при равномерном распределении данных. Худший случай: O(N) (если данные плохо распределены или находятся вблизи границ).
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
• Фибоначчи поиск
Поиск по Фибоначчи — это эффективный алгоритм поиска, используемый для нахождения целевого значения в отсортированной коллекции, такой как массив или список. По принципу он аналогичен бинарному поиску, но использует числа Фибоначчи для определения позиций для сравнения.
Объяснение работы алгоритма:
•	Подготовка чисел Фибоначчи: Генератор создает последовательность чисел Фибоначчи, достаточной длины для охвата массива.
•	Интервал поиска: Начиная с последнего числа Фибоначчи, вычисляется возможная позиция элемента в массиве.
•	Сравнивание и движение: В зависимости от результата сравнения (целевое значение больше, равно или меньше текущего элемента), либо сузить интервал поиска, либо завершить поиск.
•	Завершение: Если элемент найден, вернуть его индекс, иначе вернуть -1.
Время выполнения и сложность в нотации Big-O
В худшем случае временная сложность алгоритма поиска по Фибоначчи равна O (logφN), где φ — Золотое сечение (≈1.618). Фактически, сложность близка к бинарному поиску и эффективна для большого объема данных.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


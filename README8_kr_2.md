# Вариант 6
## Условие задания
Генетический алгоритм: бинарная оптимизация 

Условие. Найти битовую строку длины 10 с максимальной суммой единиц. 

Алгоритм: генетический алгоритм (отбор, кроссовер, мутация). 

Язык примера: C++ 

vector<bool> geneticOnes(int popSize, int generations) { 
vector<vector<bool>> population(popSize, vector<bool>(10)); 

// Инициализация случайной популяции 
for (int gen = 0; gen < generations; gen++) { 

// ДОПИСАТЬ: оценка фитнесса, отбор, кроссовер, мутация 
} 
// Вернуть лучшую особь 
} 
Что дописать: цикл эволюции популяции.
#
### Определение
Генетический алгоритм — это эволюционный алгоритм, который имитирует процесс естественного отбора для решения оптимизационных задач. Алгоритм работает с популяцией особей (решений), которые развиваются через операции отбора, скрещивания и мутации.
#
### Описание работы алгоритма

1. Инициализация популяции

Создается начальная популяция случайных бинарных строк длины 10
(vector<vector<bool>> population(popSize, vector<bool>(10));)

2. Вычисление функции приспособленности (fitness)

Для каждой особи вычисляется количество единиц в строке
(int fitness(const vector<bool>& individual))

3. Турнирный отбор

Выбираются случайные особи из популяции и среди них выбирается лучшая
(vector<bool> tournamentSelection(...))

4. Одноточечный кроссовер

Два родителя обмениваются частями своих хромосом в случайной точке
(pair<vector<bool>, vector<bool>> singlePointCrossover(...))

5. Мутация

Случайные биты инвертируются с заданной вероятностью
(void mutate(vector<bool>& individual, double mutationRate))
#
### Временная сложность
Временная сложность алгоритма составляет O(g × p × n), где:

g - количество поколений

p - размер популяции

n - длина бинарной строки

### Пояснение
Временная сложность O(g × p × n) возникает потому, что алгоритм выполняет g поколений, в каждом из которых обрабатывается p особей размера n. На каждую особь в каждом поколении выполняются операции фитнесса, отбора, кроссовера и мутации, требующие O(n) операций, что в сумме дает O(g × p × n).
#
## Ответ на контрольный вопрос 6
### Различие дробного и 0-1 рюкзака. В чем заключается принципиальное различие между дробным рюкзаком и 0-1 рюкзаком?
Принципиальное различие между дробным и 0-1 рюкзаком заключается в возможности деления предметов:

В 0-1 рюкзаке предметы неделимы - каждый предмет либо целиком помещается в рюкзак, либо нет (бинарный выбор 0 или 1)

В дробном рюкзаке предметы можно делить на части - можно взять дробную часть предмета, пропорциональную его ценности

Следствия этого различия:

Дробный рюкзак решается жадным алгоритмом (сортировка по удельной стоимости)

0-1 рюкзак требует динамического программирования (более сложное решение)

Дробный рюкзак всегда дает оптимальное решение жадным методом, а 0-1 рюкзак - нет
